## Blockchain

- [[ethereum]] - Ethereum
- [[algorand]] - Algorand
- [[reach]] - Programming with Reach

# Feynmann
1) You and your friends want to keep track of money you're paying each other.  So each time somone owes you money you add a line to the ledger letting everybody know what each time somone has an INTENTION to pay someone else. At the end of each week, if you spent more than you received, then you put your money into the pot.  If you received more than you spent, then you take your money out of the pot. The issue with just doing this is that there is nothing to stop you from saying that someone else is supposed to pay you when they really dont have to (this is an issue of trust). 

2) To address the issue of trust, each person involved in a line in the ledger, has to sign it.  Just signing it with your name wouldnt work though because anybody could copy that.  So when we say we are going to use this ledger, we create a private and public key.
    * To make it secure, you'll need to have a key that you keep to yourself and then a key you give to everybody.  You also need to relate those two keys together so that someone cant just give you a random key back and say it's what you gave them.  
    * So you have one key that is private (the one you keep to yourself and never show anybody) and you have one key thats public (the one that you give to other people).  So how do you do this?  One way is to make the public key using your own private key.  So let's say you take your private key and press it into play doh so that it LOOKS like your private key but it isnt it.  Then you take that playdoh and you make some marks on it so that it looks different than your private key.  You know what marks you made so you know which marks you need to take off to get back to your private key but other people DONT know which marks were made by you and which ones were made by your private key so they wouldnt know which marks to take off.  Then you can sign the line in the ledger by dipping your public key in ink and pressing it on to the ledger.  You can now go down the ledger and say, yes, these entries in the ledger are mine because thats my public key next to them.  Or you can say, no thats not mine because that public key doesnt have the marks I made.

3) Now that that's fixed, I noticed we have another issue.  Imagine that I owe Bob $100.  So I add that line to the ledger and then me and bob sign that line in the ledger with our public keys.  The problem now is what happens if Bob goes in and changes that $100 to $1000?  We both signed the line so right now, that would mean at the end of the week when we settle up, I would have to put 1000 in the pot instead of 100.  Oof, need to fix this problem.  
    * The way we fix it is that instead of just making the 3 lines on my public key.  I now count how many letters, numbers, and spaces are in that line of the ledger and I make that many marks on my public key.  So if the line in the ledger is: "Jacob owes Bob $100" then I would make 19 marks in my public key and sign the line with that.  So now when Bob tries to change it to "$1000", then there would need to be 20 marks on my key instead of 19 so I know that the line changed.  But what happens if he changed it to "$500" instead?  Oof, thats another problem.  To fix this, let's give a unique value to every single character that can be written in the ledger.  So if there's an A then that is 1 mark.  If there's a B then that's 2 marks. And so on through the 26 letters.  Then let's say if there's a number 0, then that is 27 marks.  The number 1 is 28 marks.  And so on for the nubmers 0-9.  Then let's add in characters like "$" is 38 marks...and so on.  This process is called hashing and the method we use is called a Hashing function.  Hashing is a lot more complicated than what we have now but it guarantees a unique value that has a specific length (eg, in our simple example above we got a value of 19 for 19 characters in the message.  That has a specific length of 2 for the 2 digits in it.  But lets say we wanted to each hash to be 10 digits long, then we could re-write 19 as 0000000019 instead of just 19 after going through the message).  A hashing algorithm is a mathematical formula (some common ones are SHA256, MD5, etc are hashing functions) that you can use on every message to generate a unique value with a fixed length. That unique value is then run through another mathematical forumla that uses your public key.  So now, nobody can change the line after you sign it. BUT if you take the message and your public key, you can confirm whether or not the signature on that line is actually yours.
      * This defines two formulas: 
        * Signature function is to come up with the signature for a message using your private key.  You take your private key and the message and that gives you your signature for that document.  In our example, you would take the private key, add marks to it, and that gives you a public key.  Then you take the message characters and you change each one into numbers and add them up and that gives you a message hash.  Then you take your public key and multiply it with the message hash.  and that gives you your signature.
        * Verification function is to take the Message, the signature you made, and the public key that you used.  The verification function takes those 3 values and sees if your signature =  message / public key.  If it does then it returns true otherwise it returns false.
        * **Note**: I'm using multiply and divide as examples of hashing functions but those arent actually used in real life.  Multiple and divide are just the functions we are using to come up with the signature and verification.  In the real world, those functions are a lot more complex.
        * **Note**: Hashing functions, like SHA256, are called cryptographic hash functions and are special for a few reasons: 
          * the value they create can NOT be reversed to find the input.  For example, if you used SHA256 on the message "my name is jacob" it would produce some value that is 256 digits in length and each of those digits would be a 1 or a 0.  Currently there is NO WAY to take that 256 digit value and figure out that the message that created it was "my name is jacob".  This is called "resistance to preimages"
          * the value they create will be unique to all other possible inputs.  So SHA256 on the message "my name is jacob" will produce an output that will NOT be created by another message you put in. This is called "resistance to collisions"
          * if you are given a message you cannot find another message that has the same value.  This is called "resistance to secondary preimages".  And yes, this is implied by the fact that we said there cant be any collisions.  
          * If any of the above things prove to be false about a hashing function, then we say that hashing function is cracked.  For example, the MD5 hashing algorithm was cracked because someone proved that different messages produced the same output (which means it didnt avoid collisions).  

4) Now that that's fixed, I noticed another issue.  So now, we can be sure that the line in the ledger is valid because Bob and I both signed it.  But now the problem is, what is stopping Bob from just copying that line over and over again? 
    * To handle this, we assign a unique number to each line in our ledger and we use that number in our Signature function.  So let's say you just just number every line in the ledger from 1 - however many lines are in the ledger.  Now, when you run your signature function, you pass that line in the ledger too.  Now we can be sure that each line is valid because we signed it AND because it is unique to that line.

5) Okay, now we can be sure that all intentions recorded in the ledger are valid and true.  So now the next problem we want to solve is how do we make sure that people dont add intentions that they cant afford?  Let's say I have $100 and I make two entry lines to Bob saying I intend to pay him $50 and another line saying I intend to pay him $50 more.  Now, I tell Alice that I intend to pay her $50.  Well, I dont have that money so when we settle up at the end of the week, I wont be able to pay Alice.  In addition, there's nothing stopping me from just not settling up with Bob either.  In the "real world", we have credit cards, loans, etc that temporarily give more money than we actually have.  We dont want that because we want people to know that every intention will be carried out and that if you use our blockchain, then you will never be ripped off.  
    * The way we address this is that we say, okay if you want to use our ledger, then you have to use JacobBucks (JB for short).  And to get JacobBucks, you need to pay us $100 for each JacobBuck.  
    * So now, when you and your friends add an intention to the ledger, we can confirm whether or not you have enough JBs to fulfill that intention.  If you do, then we add that line to the ledger.  If you dont, then we dont add that line to the ledger. 

6) Now we know that every line in the ledger is true and that every line that gets added is going to be settled up.  The next problem we have to solve is how can we trust the person holding the ledger and adding the lines?  If that person that's actually writing in the lines of the ledger is sick, then we cant stop lines being written for that day.  If the preson thats holding the ledger decides to burn it, then that would suck too.  This problem is called the centralization problem.  The ledger is in one place and one person controls it.  This would be better if everybody that every person that uses our ledger has a copy of it and whenever someone decides to add a line to the ledger, they tell everybody else and everybody adds it to their own copy.  This is called decentralization because if we did things that way, where everybody has their own copy of the ledger, then there isnt one person in charge.  If someone decides to stop using our ledger, thats perfectly fine because everybody else still has a copy and all those copies are the same.  So decentralization is good but how do we do it?
    * We could do this by giving each person that wants to use our ledger, a ledger of their own that has all the intentions up until that point.  Then, everytime someone wants to add a new line to the ledger, they tell everybody else "hey, im adding this line so you guys add it to yours too".  That way everybody's ledger is the same.  This is called "broadcasting".  You are broadcasting to everybody that has a ledger that you are going to add a line.  So now, things are no longer centralized.  Everybody has their own ledger and every ledger has the same lines in it.  
    * So now we know that we cant trust each line of the ledger because of the signatures on each line, we can trust that each person is going to settle up at the end of the week because everybody is using JBs, and we know that no one can destroy all the intentions because everybody has a copy.  

7) Here is where we get to the big problem.  How do we make sure that everybody gets the broadcast and also that everybody updates their own ledger in the same order as everybody elses.  We need to make sure everybody hears that someone else is adding a line and also everybody puts those lines in the same order in their ledger as everybody else's ledger.  
    * The making sure everybody hears it at the same time is fixed by putting those ledgers on the internet.  So when you "say" it, you are "saying" it on the internet so it goes everywhere almost immediately.  
    * The making sure everybody updates their ledger at the same time and in the same order problem is a lot trickier. This problem is what was solved by the original Bitcoin paper.  That paper, written by Satoshi Nakamoto (pseudonym for some unknown or person or group that wrote the paper) proposed a solution to this problem called "Proof of Work".
      * Satoshi proposed that you have to combine a group of transactions, then come up with a SEED Value (which is a random number), then combine that SEED value and the group of transactions, then run that through SHA256 to get a final value (this final value is called a Proof of Work).  
      * Now that doesnt really do much because anybody can just come up with a SEED value and group transactions and run them through SHA256. So Satsohi said, we should make a requirement that the value after applying SHA256 starts with 30 0s.  So now, figuring out a seed value is a lot tougher and requires a lot of work.  The Proof of that Work is that you get a Proof of Work value that is 256 bits long and that the first 30 bits of that number are 0s.  Now that isnt easy to find that seed value but its not impossible either.  If you just guessed a seed value, the probability that the guessed seed value would result in a Proof of Work value starting with 30 0s is 1 in a BILLION.  
    * For example, Let's say person A broadcast a message saying "Jacob owes Bob $100", person B broadcasts a message saying "Alice owes Apu $175", and person C broadcasts that "John owes Alice $1000".  Each of those were signed before they were broadcast.  Now, I need to come up with some number that I can add to that list of signed transactions so that when I run it through SHA256 I get a value that is 256 bits (0s and 1s) long AND the first 30 of those bits are 0s.  
    * So each "block" is made up that group of transactions, that proof of work number, and the value produced by using SHA256 (the value that starts with the 30 0s).  
    * Each block also has an identifier.  That identifier is the SHA256 hash of the the previous block's SHA256 result value.  
      * So lets say I just created Block A which has the person A, B, C signed transactions AND the Proof of Work value 839201938 and the resulting SHA256 hash of those transactions that is 256 bits long with 30 0s at the beginning.  Let's call that Block A's Block ID.  Now we create the next block, Block B, that has transactions for person G, H, A, L, F and a Proof of Work value 748202384.  To create the "chain" Block B, takes Block A's Block ID and runs it through SHA256.  Block B takes the result of hashing Block A's Block ID, and uses that value as it's chain ID.  So now if someone tried to change a transaction in Block A, it would break the block because the result of the SHA 256 wouldnt start with 30 0s AND if they changed block A so that it DID have a SHA 256 value with 30 0s, that value wouldnt match what was in Block B.  Same thing applies with order.  You couldnt move Block B before block A because Block A's chain ID would be invalid.  
    * When the block is created, it is broadcast to everybody and everybody updates their chain (i.e. their ledger) with that block.
      * The person that creates tht block is called a miner
      * The miner, when they create the block, gets rewarded by the system by having the system add a reward transaction to the top of the list of transactions in it's block.  So each time a miner creates a block, they get rewarded by the system with JBs.  That also adds more JBs to supply of JBs in the system.  For example, let's say there are a total of 100 JBs in the system and you create a block, the system could reward you with 10 JBs by adding that transaction to the top of your block's list of transactions.  Now there would be 110 JBs in the system.  This is how value is created in the system.

8) So now we know how blocks are made and how the chain is built.  The last problem is what if two different miners create and broadcast creation of a block at the same time?  
    * In this case, each person that has a copy of the ledger would take the blockchain from the miner that has the most blocks in it.
    * If there is a tie and two different miners broadcast a new block at the same time, then you wait to add it to your own ledger until the one of them produces another block faster and broadcasts a longer chain.
    * **IMPORTANT** - Miners always broadcast their full blockchain.  Ledgers always take the blockchain that has the most blocks on it.  

**Differences in blockchains**
1) Bitcoin actually varies it's requirement for number of 0s at the beginning of its Proof of Work (its not always 30 0s). So that it takes an average of about 10 minutes to crate a block.
   1) Bitcoin has an average block time of 10 minutes.  Ethereum is 15 seconds.  Ripple is 3.5 seconds.  
2) Different chains use different methods to confirm blocks on a chain. The main versions are:
   a) Proof-of-Work: Nodes are any machine willing to create blocks.  Majority decision is represented by "longest-chain-wins" rule.  The participants in the network accept the longest chain of blocks as being the valid one.
      i)  Nodes create blocks. 
      ii) The nodes, "miners", that do the really difficult math problem to create a block and broadcast when they find a solution of creating a block.
   b) Proof-of-Stake: Nodes are any machines that put up money in an escrow account to participate in the validation/block creation process.  Nodes that "stake" their money, are then randomly selected to be block creators or validators.  
      i)  Nodes in the network validate blocks rather than create them
      ii) The nodes put their own money into an "escrow" account to participate as a validator.  The network randomly selects which nodes are validators from the list of nodes that paid in to be validators.  When they are selected, the nodes validate submitted blocks and if the group of validator nodes confirm the block, then it gets added to the chain. 

**Special things about Bitcoin**
* Every 210,000 blocks, the reward to the miner gets cut in half.  When Bitcoin first started the reward was 50 Bitcoin per block.  Today it's 6 Bitcoin per block.
* Because the reward is halved every 210,000 blocks, eventually you will get to a point where there are no more rewards.  At that point the system will stop adding Bitcoin to the system.  At that point, there will be 21 million Bitcoin total.  
* Each block contains around 2400 transactions.  
* When a person broadcasts their transaction, they add a transaction fee to it.  The miner gets to keep the transaction fee.  So if you increase your transaction fee, its more likely that your transaction will be included in the next block.
* After the total 21 million Bitcoins are dispersed, miners will earn money just through transaction fees.









Anyone can add lines to the ledger
At the end of every week 

1) Public Ledger of all transactions

[//begin]: # "Autogenerated link references for markdown compatibility"
[ethereum]: ethereum/ethereum "Ethereum"
[algorand]: algorand/algorand "Algorand"
[reach]: programming/reach/reach "Reach"
[//end]: # "Autogenerated link references"